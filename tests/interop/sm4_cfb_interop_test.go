package interop

import (
	"encoding/hex"
	"testing"

	"github.com/lihongjie0209/sm-go-bc/crypto/engines"
	"github.com/lihongjie0209/sm-go-bc/crypto/modes"
	"github.com/lihongjie0209/sm-go-bc/crypto/params"
)

// TestSM4CFBInterop tests SM4-CFB mode interoperability with JS implementation
func TestSM4CFBInterop(t *testing.T) {
	tests := []struct {
		name      string
		key       string
		iv        string
		plaintext string
		// These ciphertexts should be generated by JS implementation
		// For now, we verify Go encrypt/decrypt works correctly
	}{
		{
			name:      "CFB128 Test 1",
			key:       "0123456789ABCDEFFEDCBA9876543210",
			iv:        "0123456789ABCDEFFEDCBA9876543210",
			plaintext: "Hello, World!",
		},
		{
			name:      "CFB128 Test 2",
			key:       "0123456789ABCDEFFEDCBA9876543210",
			iv:        "FEDCBA98765432100123456789ABCDEF",
			plaintext: "SM4-CFB mode encryption test",
		},
		{
			name:      "CFB8 Test 1",
			key:       "0123456789ABCDEFFEDCBA9876543210",
			iv:        "0123456789ABCDEFFEDCBA9876543210",
			plaintext: "Byte-by-byte",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			key, _ := hex.DecodeString(tt.key)
			iv, _ := hex.DecodeString(tt.iv)
			plaintext := []byte(tt.plaintext)

			// Determine block size from test name
			bitBlockSize := 128
			if len(tt.name) >= 4 && tt.name[:4] == "CFB8" {
				bitBlockSize = 8
			}

			// Create cipher
			engine := engines.NewSM4Engine()
			cfb := modes.NewCFBBlockCipher(engine, bitBlockSize)

			// Encrypt
			keyParam := params.NewKeyParameter(key)
			ivParam := params.NewParametersWithIV(keyParam, iv)
			cfb.Init(true, ivParam)

			ciphertext := make([]byte, len(plaintext))
			cfb.ProcessBytes(plaintext, 0, len(plaintext), ciphertext, 0)

			t.Logf("Plaintext:  %s", plaintext)
			t.Logf("Ciphertext: %s", hex.EncodeToString(ciphertext))

			// Decrypt
			cfb.Init(false, ivParam)
			decrypted := make([]byte, len(ciphertext))
			cfb.ProcessBytes(ciphertext, 0, len(ciphertext), decrypted, 0)

			// Verify
			if string(plaintext) != string(decrypted) {
				t.Errorf("Decryption failed\nExpected: %s\nGot: %s", plaintext, decrypted)
			}
		})
	}
}

// TestSM4CFBKnownVectors tests with known test vectors
// These vectors can be cross-verified with JS implementation
func TestSM4CFBKnownVectors(t *testing.T) {
	// Standard test key
	key, _ := hex.DecodeString("0123456789ABCDEFFEDCBA9876543210")
	iv, _ := hex.DecodeString("0123456789ABCDEFFEDCBA9876543210")

	tests := []struct {
		name         string
		bitBlockSize int
		plaintext    string
		expected     string // Expected ciphertext (hex)
	}{
		// TODO: Add expected ciphertexts from JS implementation
		// For now, we just test encrypt/decrypt consistency
		{
			name:         "CFB128 Empty",
			bitBlockSize: 128,
			plaintext:    "",
			expected:     "",
		},
		{
			name:         "CFB128 Single Block",
			bitBlockSize: 128,
			plaintext:    "1234567890123456",
			expected:     "", // To be filled with JS output
		},
		{
			name:         "CFB8 Test",
			bitBlockSize: 8,
			plaintext:    "Test",
			expected:     "", // To be filled with JS output
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			plaintext := []byte(tt.plaintext)

			// Create cipher
			engine := engines.NewSM4Engine()
			cfb := modes.NewCFBBlockCipher(engine, tt.bitBlockSize)

			// Encrypt
			keyParam := params.NewKeyParameter(key)
			ivParam := params.NewParametersWithIV(keyParam, iv)
			cfb.Init(true, ivParam)

			ciphertext := make([]byte, len(plaintext))
			if len(plaintext) > 0 {
				cfb.ProcessBytes(plaintext, 0, len(plaintext), ciphertext, 0)
			}

			t.Logf("Plaintext:  %s", hex.EncodeToString(plaintext))
			t.Logf("Ciphertext: %s", hex.EncodeToString(ciphertext))

			// If expected is provided, verify it
			if tt.expected != "" {
				expectedBytes, _ := hex.DecodeString(tt.expected)
				if hex.EncodeToString(ciphertext) != tt.expected {
					t.Errorf("Ciphertext mismatch\nExpected: %s\nGot: %s",
						hex.EncodeToString(expectedBytes), hex.EncodeToString(ciphertext))
				}
			}

			// Decrypt and verify
			cfb.Init(false, ivParam)
			decrypted := make([]byte, len(ciphertext))
			if len(ciphertext) > 0 {
				cfb.ProcessBytes(ciphertext, 0, len(ciphertext), decrypted, 0)
			}

			if string(plaintext) != string(decrypted) {
				t.Errorf("Decryption failed\nExpected: %s\nGot: %s",
					hex.EncodeToString(plaintext), hex.EncodeToString(decrypted))
			}
		})
	}
}

// TestSM4CFBMultipleBlocks tests encryption of multiple blocks
func TestSM4CFBMultipleBlocks(t *testing.T) {
	key, _ := hex.DecodeString("0123456789ABCDEFFEDCBA9876543210")
	iv, _ := hex.DecodeString("0123456789ABCDEFFEDCBA9876543210")

	// Test with different data sizes
	sizes := []int{0, 1, 15, 16, 17, 31, 32, 33, 64, 128, 256, 1024}

	for _, size := range sizes {
		t.Run(hex.EncodeToString([]byte{byte(size)}), func(t *testing.T) {
			plaintext := make([]byte, size)
			for i := range plaintext {
				plaintext[i] = byte(i % 256)
			}

			// Test CFB128
			engine := engines.NewSM4Engine()
			cfb := modes.NewCFBBlockCipher(engine, 128)

			keyParam := params.NewKeyParameter(key)
			ivParam := params.NewParametersWithIV(keyParam, iv)

			// Encrypt
			cfb.Init(true, ivParam)
			ciphertext := make([]byte, len(plaintext))
			if len(plaintext) > 0 {
				cfb.ProcessBytes(plaintext, 0, len(plaintext), ciphertext, 0)
			}

			// Decrypt
			cfb.Init(false, ivParam)
			decrypted := make([]byte, len(ciphertext))
			if len(ciphertext) > 0 {
				cfb.ProcessBytes(ciphertext, 0, len(ciphertext), decrypted, 0)
			}

			// Verify
			if len(plaintext) != len(decrypted) {
				t.Errorf("Length mismatch: expected %d, got %d", len(plaintext), len(decrypted))
			}

			for i := range plaintext {
				if plaintext[i] != decrypted[i] {
					t.Errorf("Byte mismatch at position %d: expected %02x, got %02x",
						i, plaintext[i], decrypted[i])
					break
				}
			}
		})
	}
}
